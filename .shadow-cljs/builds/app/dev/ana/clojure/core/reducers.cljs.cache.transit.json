["^ ","~:output",["^ ","~:js","goog.provide('clojure.core.reducers');\ngoog.require('cljs.core');\nclojure.core.reducers.fjtask = (function clojure$core$reducers$fjtask(f){\nreturn f;\n});\nclojure.core.reducers.fjinvoke = (function clojure$core$reducers$fjinvoke(f){\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n});\nclojure.core.reducers.fjfork = (function clojure$core$reducers$fjfork(task){\nreturn task;\n});\nclojure.core.reducers.fjjoin = (function clojure$core$reducers$fjjoin(task){\nreturn (task.cljs$core$IFn$_invoke$arity$0 ? task.cljs$core$IFn$_invoke$arity$0() : task.call(null));\n});\n/**\n * Like core/reduce except:\n *   When init is not provided, (f) is used.\n *   Maps are reduced with reduce-kv\n */\nclojure.core.reducers.reduce = (function clojure$core$reducers$reduce(var_args){\nvar G__41862 = arguments.length;\nswitch (G__41862) {\ncase 2:\nreturn clojure.core.reducers.reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn clojure.core.reducers.reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nclojure.core.reducers.reduce.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nreturn clojure.core.reducers.reduce.cljs$core$IFn$_invoke$arity$3(f,(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)),coll);\n});\n\nclojure.core.reducers.reduce.cljs$core$IFn$_invoke$arity$3 = (function (f,init,coll){\nif(cljs.core.map_QMARK_(coll)){\nreturn cljs.core._kv_reduce(coll,f,init);\n} else {\nif((coll == null)){\nreturn init;\n} else {\nif(cljs.core.array_QMARK_(coll)){\nvar fexpr__41884 = new cljs.core.Var(function(){return cljs.core.array_reduce;},new cljs.core.Symbol(\"cljs.core\",\"array-reduce\",\"cljs.core/array-reduce\",569260567,null),cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"private\",\"private\",-558947994),new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),new cljs.core.Keyword(null,\"name\",\"name\",1843675177),new cljs.core.Keyword(null,\"file\",\"file\",-1269645878),new cljs.core.Keyword(null,\"end-column\",\"end-column\",1425389514),new cljs.core.Keyword(null,\"top-fn\",\"top-fn\",-2056129173),new cljs.core.Keyword(null,\"column\",\"column\",2078222095),new cljs.core.Keyword(null,\"line\",\"line\",212345235),new cljs.core.Keyword(null,\"end-line\",\"end-line\",1837326455),new cljs.core.Keyword(null,\"arglists\",\"arglists\",1661989754),new cljs.core.Keyword(null,\"doc\",\"doc\",1913296891),new cljs.core.Keyword(null,\"test\",\"test\",577538877)],[true,new cljs.core.Symbol(null,\"cljs.core\",\"cljs.core\",770546058,null),new cljs.core.Symbol(null,\"array-reduce\",\"array-reduce\",154113968,null),\"cljs/core.cljs\",(20),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\"variadic?\",\"variadic?\",584179762),false,new cljs.core.Keyword(null,\"fixed-arity\",\"fixed-arity\",1586445869),(4),new cljs.core.Keyword(null,\"max-fixed-arity\",\"max-fixed-arity\",-690205543),(4),new cljs.core.Keyword(null,\"method-params\",\"method-params\",-980792179),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"f\",\"f\",43394975,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"f\",\"f\",43394975,null),new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null)], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"f\",\"f\",43394975,null),new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null),new cljs.core.Symbol(null,\"idx\",\"idx\",-1600747296,null)], null)),new cljs.core.Keyword(null,\"arglists\",\"arglists\",1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"f\",\"f\",43394975,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"f\",\"f\",43394975,null),new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null)], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"f\",\"f\",43394975,null),new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null),new cljs.core.Symbol(null,\"idx\",\"idx\",-1600747296,null)], null)),new cljs.core.Keyword(null,\"arglists-meta\",\"arglists-meta\",1944829838),cljs.core.list(null,null,null)], null),(1),(1487),(1487),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"f\",\"f\",43394975,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"f\",\"f\",43394975,null),new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null)], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"f\",\"f\",43394975,null),new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null),new cljs.core.Symbol(null,\"idx\",\"idx\",-1600747296,null)], null)),null,(cljs.core.truth_(cljs.core.array_reduce)?cljs.core.array_reduce.cljs$lang$test:null)]));\nreturn (fexpr__41884.cljs$core$IFn$_invoke$arity$3 ? fexpr__41884.cljs$core$IFn$_invoke$arity$3(coll,f,init) : fexpr__41884.call(null,coll,f,init));\n} else {\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3(coll,f,init);\n\n}\n}\n}\n});\n\nclojure.core.reducers.reduce.cljs$lang$maxFixedArity = 3;\n\n\n/**\n * @interface\n */\nclojure.core.reducers.CollFold = function(){};\n\nclojure.core.reducers.coll_fold = (function clojure$core$reducers$coll_fold(coll,n,combinef,reducef){\nif((((!((coll == null)))) && ((!((coll.clojure$core$reducers$CollFold$coll_fold$arity$4 == null)))))){\nreturn coll.clojure$core$reducers$CollFold$coll_fold$arity$4(coll,n,combinef,reducef);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (clojure.core.reducers.coll_fold[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$4(coll,n,combinef,reducef) : m__4434__auto__.call(null,coll,n,combinef,reducef));\n} else {\nvar m__4431__auto__ = (clojure.core.reducers.coll_fold[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$4(coll,n,combinef,reducef) : m__4431__auto__.call(null,coll,n,combinef,reducef));\n} else {\nthrow cljs.core.missing_protocol(\"CollFold.coll-fold\",coll);\n}\n}\n}\n});\n\n/**\n * Reduces a collection using a (potentially parallel) reduce-combine\n *   strategy. The collection is partitioned into groups of approximately\n *   n (default 512), each of which is reduced with reducef (with a seed\n *   value obtained by calling (combinef) with no arguments). The results\n *   of these reductions are then reduced with combinef (default\n *   reducef). combinef must be associative, and, when called with no\n *   arguments, (combinef) must produce its identity element. These\n *   operations may be performed in parallel, but the results will\n *   preserve order.\n * \n *   Note: Performing operations in parallel is currently not implemented.\n */\nclojure.core.reducers.fold = (function clojure$core$reducers$fold(var_args){\nvar G__41907 = arguments.length;\nswitch (G__41907) {\ncase 2:\nreturn clojure.core.reducers.fold.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn clojure.core.reducers.fold.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn clojure.core.reducers.fold.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nclojure.core.reducers.fold.cljs$core$IFn$_invoke$arity$2 = (function (reducef,coll){\nreturn clojure.core.reducers.fold.cljs$core$IFn$_invoke$arity$3(reducef,reducef,coll);\n});\n\nclojure.core.reducers.fold.cljs$core$IFn$_invoke$arity$3 = (function (combinef,reducef,coll){\nreturn clojure.core.reducers.fold.cljs$core$IFn$_invoke$arity$4((512),combinef,reducef,coll);\n});\n\nclojure.core.reducers.fold.cljs$core$IFn$_invoke$arity$4 = (function (n,combinef,reducef,coll){\nreturn clojure.core.reducers.coll_fold(coll,n,combinef,reducef);\n});\n\nclojure.core.reducers.fold.cljs$lang$maxFixedArity = 4;\n\n/**\n * Given a reducible collection, and a transformation function xf,\n *   returns a reducible collection, where any supplied reducing\n *   fn will be transformed by xf. xf is a function of reducing fn to\n *   reducing fn.\n */\nclojure.core.reducers.reducer = (function clojure$core$reducers$reducer(coll,xf){\nif((typeof clojure !== 'undefined') && (typeof clojure.core !== 'undefined') && (typeof clojure.core.reducers !== 'undefined') && (typeof clojure.core.reducers.t_clojure$core$reducers41910 !== 'undefined')){\n} else {\n\n/**\n* @constructor\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\nclojure.core.reducers.t_clojure$core$reducers41910 = (function (coll,xf,meta41911){\nthis.coll = coll;\nthis.xf = xf;\nthis.meta41911 = meta41911;\nthis.cljs$lang$protocol_mask$partition0$ = 917504;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\nclojure.core.reducers.t_clojure$core$reducers41910.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (_41912,meta41911__$1){\nvar self__ = this;\nvar _41912__$1 = this;\nreturn (new clojure.core.reducers.t_clojure$core$reducers41910(self__.coll,self__.xf,meta41911__$1));\n});\n\nclojure.core.reducers.t_clojure$core$reducers41910.prototype.cljs$core$IMeta$_meta$arity$1 = (function (_41912){\nvar self__ = this;\nvar _41912__$1 = this;\nreturn self__.meta41911;\n});\n\nclojure.core.reducers.t_clojure$core$reducers41910.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (this$,f1){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1.cljs$core$IReduce$_reduce$arity$3(null,f1,(f1.cljs$core$IFn$_invoke$arity$0 ? f1.cljs$core$IFn$_invoke$arity$0() : f1.call(null)));\n});\n\nclojure.core.reducers.t_clojure$core$reducers41910.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (_,f1,init){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3(self__.coll,(self__.xf.cljs$core$IFn$_invoke$arity$1 ? self__.xf.cljs$core$IFn$_invoke$arity$1(f1) : self__.xf.call(null,f1)),init);\n});\n\nclojure.core.reducers.t_clojure$core$reducers41910.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"coll\",\"coll\",-1006698606,null),new cljs.core.Symbol(null,\"xf\",\"xf\",2042434515,null),new cljs.core.Symbol(null,\"meta41911\",\"meta41911\",-554309808,null)], null);\n});\n\nclojure.core.reducers.t_clojure$core$reducers41910.cljs$lang$type = true;\n\nclojure.core.reducers.t_clojure$core$reducers41910.cljs$lang$ctorStr = \"clojure.core.reducers/t_clojure$core$reducers41910\";\n\nclojure.core.reducers.t_clojure$core$reducers41910.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"clojure.core.reducers/t_clojure$core$reducers41910\");\n});\n\n/**\n * Positional factory function for clojure.core.reducers/t_clojure$core$reducers41910.\n */\nclojure.core.reducers.__GT_t_clojure$core$reducers41910 = (function clojure$core$reducers$reducer_$___GT_t_clojure$core$reducers41910(coll__$1,xf__$1,meta41911){\nreturn (new clojure.core.reducers.t_clojure$core$reducers41910(coll__$1,xf__$1,meta41911));\n});\n\n}\n\nreturn (new clojure.core.reducers.t_clojure$core$reducers41910(coll,xf,cljs.core.PersistentArrayMap.EMPTY));\n});\n/**\n * Given a foldable collection, and a transformation function xf,\n *   returns a foldable collection, where any supplied reducing\n *   fn will be transformed by xf. xf is a function of reducing fn to\n *   reducing fn.\n */\nclojure.core.reducers.folder = (function clojure$core$reducers$folder(coll,xf){\nif((typeof clojure !== 'undefined') && (typeof clojure.core !== 'undefined') && (typeof clojure.core.reducers !== 'undefined') && (typeof clojure.core.reducers.t_clojure$core$reducers41943 !== 'undefined')){\n} else {\n\n/**\n* @constructor\n * @implements {clojure.core.reducers.CollFold}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\nclojure.core.reducers.t_clojure$core$reducers41943 = (function (coll,xf,meta41944){\nthis.coll = coll;\nthis.xf = xf;\nthis.meta41944 = meta41944;\nthis.cljs$lang$protocol_mask$partition0$ = 917504;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\nclojure.core.reducers.t_clojure$core$reducers41943.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (_41945,meta41944__$1){\nvar self__ = this;\nvar _41945__$1 = this;\nreturn (new clojure.core.reducers.t_clojure$core$reducers41943(self__.coll,self__.xf,meta41944__$1));\n});\n\nclojure.core.reducers.t_clojure$core$reducers41943.prototype.cljs$core$IMeta$_meta$arity$1 = (function (_41945){\nvar self__ = this;\nvar _41945__$1 = this;\nreturn self__.meta41944;\n});\n\nclojure.core.reducers.t_clojure$core$reducers41943.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (_,f1){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3(self__.coll,(self__.xf.cljs$core$IFn$_invoke$arity$1 ? self__.xf.cljs$core$IFn$_invoke$arity$1(f1) : self__.xf.call(null,f1)),(f1.cljs$core$IFn$_invoke$arity$0 ? f1.cljs$core$IFn$_invoke$arity$0() : f1.call(null)));\n});\n\nclojure.core.reducers.t_clojure$core$reducers41943.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (_,f1,init){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3(self__.coll,(self__.xf.cljs$core$IFn$_invoke$arity$1 ? self__.xf.cljs$core$IFn$_invoke$arity$1(f1) : self__.xf.call(null,f1)),init);\n});\n\nclojure.core.reducers.t_clojure$core$reducers41943.prototype.clojure$core$reducers$CollFold$ = cljs.core.PROTOCOL_SENTINEL;\n\nclojure.core.reducers.t_clojure$core$reducers41943.prototype.clojure$core$reducers$CollFold$coll_fold$arity$4 = (function (_,n,combinef,reducef){\nvar self__ = this;\nvar ___$1 = this;\nreturn clojure.core.reducers.coll_fold(self__.coll,n,combinef,(self__.xf.cljs$core$IFn$_invoke$arity$1 ? self__.xf.cljs$core$IFn$_invoke$arity$1(reducef) : self__.xf.call(null,reducef)));\n});\n\nclojure.core.reducers.t_clojure$core$reducers41943.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"coll\",\"coll\",-1006698606,null),new cljs.core.Symbol(null,\"xf\",\"xf\",2042434515,null),new cljs.core.Symbol(null,\"meta41944\",\"meta41944\",1345620729,null)], null);\n});\n\nclojure.core.reducers.t_clojure$core$reducers41943.cljs$lang$type = true;\n\nclojure.core.reducers.t_clojure$core$reducers41943.cljs$lang$ctorStr = \"clojure.core.reducers/t_clojure$core$reducers41943\";\n\nclojure.core.reducers.t_clojure$core$reducers41943.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"clojure.core.reducers/t_clojure$core$reducers41943\");\n});\n\n/**\n * Positional factory function for clojure.core.reducers/t_clojure$core$reducers41943.\n */\nclojure.core.reducers.__GT_t_clojure$core$reducers41943 = (function clojure$core$reducers$folder_$___GT_t_clojure$core$reducers41943(coll__$1,xf__$1,meta41944){\nreturn (new clojure.core.reducers.t_clojure$core$reducers41943(coll__$1,xf__$1,meta41944));\n});\n\n}\n\nreturn (new clojure.core.reducers.t_clojure$core$reducers41943(coll,xf,cljs.core.PersistentArrayMap.EMPTY));\n});\n/**\n * Applies f to every value in the reduction of coll. Foldable.\n */\nclojure.core.reducers.map = (function clojure$core$reducers$map(var_args){\nvar G__41952 = arguments.length;\nswitch (G__41952) {\ncase 1:\nreturn clojure.core.reducers.map.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.core.reducers.map.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nclojure.core.reducers.map.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn (function (x__4245__auto__){\nreturn clojure.core.reducers.map.cljs$core$IFn$_invoke$arity$2(f,x__4245__auto__);\n});\n});\n\nclojure.core.reducers.map.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nreturn clojure.core.reducers.folder(coll,(function (f1){\nreturn (function() {\nvar G__42126 = null;\nvar G__42126__0 = (function (){\nreturn (f1.cljs$core$IFn$_invoke$arity$0 ? f1.cljs$core$IFn$_invoke$arity$0() : f1.call(null));\n});\nvar G__42126__2 = (function (ret,v){\nvar G__41955 = ret;\nvar G__41956 = (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(v) : f.call(null,v));\nreturn (f1.cljs$core$IFn$_invoke$arity$2 ? f1.cljs$core$IFn$_invoke$arity$2(G__41955,G__41956) : f1.call(null,G__41955,G__41956));\n});\nvar G__42126__3 = (function (ret,k,v){\nvar G__41957 = ret;\nvar G__41958 = (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(k,v) : f.call(null,k,v));\nreturn (f1.cljs$core$IFn$_invoke$arity$2 ? f1.cljs$core$IFn$_invoke$arity$2(G__41957,G__41958) : f1.call(null,G__41957,G__41958));\n});\nG__42126 = function(ret,k,v){\nswitch(arguments.length){\ncase 0:\nreturn G__42126__0.call(this);\ncase 2:\nreturn G__42126__2.call(this,ret,k);\ncase 3:\nreturn G__42126__3.call(this,ret,k,v);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__42126.cljs$core$IFn$_invoke$arity$0 = G__42126__0;\nG__42126.cljs$core$IFn$_invoke$arity$2 = G__42126__2;\nG__42126.cljs$core$IFn$_invoke$arity$3 = G__42126__3;\nreturn G__42126;\n})()\n}));\n});\n\nclojure.core.reducers.map.cljs$lang$maxFixedArity = 2;\n\n/**\n * Applies f to every value in the reduction of coll, concatenating the result\n *   colls of (f val). Foldable.\n */\nclojure.core.reducers.mapcat = (function clojure$core$reducers$mapcat(var_args){\nvar G__41965 = arguments.length;\nswitch (G__41965) {\ncase 1:\nreturn clojure.core.reducers.mapcat.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.core.reducers.mapcat.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nclojure.core.reducers.mapcat.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn (function (x__4245__auto__){\nreturn clojure.core.reducers.mapcat.cljs$core$IFn$_invoke$arity$2(f,x__4245__auto__);\n});\n});\n\nclojure.core.reducers.mapcat.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nreturn clojure.core.reducers.folder(coll,(function (f1){\nreturn (function() {\nvar G__42137 = null;\nvar G__42137__0 = (function (){\nreturn (f1.cljs$core$IFn$_invoke$arity$0 ? f1.cljs$core$IFn$_invoke$arity$0() : f1.call(null));\n});\nvar G__42137__2 = (function (ret,v){\nreturn clojure.core.reducers.reduce.cljs$core$IFn$_invoke$arity$3(f1,ret,(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(v) : f.call(null,v)));\n});\nvar G__42137__3 = (function (ret,k,v){\nreturn clojure.core.reducers.reduce.cljs$core$IFn$_invoke$arity$3(f1,ret,(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(k,v) : f.call(null,k,v)));\n});\nG__42137 = function(ret,k,v){\nswitch(arguments.length){\ncase 0:\nreturn G__42137__0.call(this);\ncase 2:\nreturn G__42137__2.call(this,ret,k);\ncase 3:\nreturn G__42137__3.call(this,ret,k,v);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__42137.cljs$core$IFn$_invoke$arity$0 = G__42137__0;\nG__42137.cljs$core$IFn$_invoke$arity$2 = G__42137__2;\nG__42137.cljs$core$IFn$_invoke$arity$3 = G__42137__3;\nreturn G__42137;\n})()\n}));\n});\n\nclojure.core.reducers.mapcat.cljs$lang$maxFixedArity = 2;\n\n/**\n * Retains values in the reduction of coll for which (pred val)\n *   returns logical true. Foldable.\n */\nclojure.core.reducers.filter = (function clojure$core$reducers$filter(var_args){\nvar G__41974 = arguments.length;\nswitch (G__41974) {\ncase 1:\nreturn clojure.core.reducers.filter.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.core.reducers.filter.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nclojure.core.reducers.filter.cljs$core$IFn$_invoke$arity$1 = (function (pred){\nreturn (function (x__4245__auto__){\nreturn clojure.core.reducers.filter.cljs$core$IFn$_invoke$arity$2(pred,x__4245__auto__);\n});\n});\n\nclojure.core.reducers.filter.cljs$core$IFn$_invoke$arity$2 = (function (pred,coll){\nreturn clojure.core.reducers.folder(coll,(function (f1){\nreturn (function() {\nvar G__42140 = null;\nvar G__42140__0 = (function (){\nreturn (f1.cljs$core$IFn$_invoke$arity$0 ? f1.cljs$core$IFn$_invoke$arity$0() : f1.call(null));\n});\nvar G__42140__2 = (function (ret,v){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(v) : pred.call(null,v)))){\nreturn (f1.cljs$core$IFn$_invoke$arity$2 ? f1.cljs$core$IFn$_invoke$arity$2(ret,v) : f1.call(null,ret,v));\n} else {\nreturn ret;\n}\n});\nvar G__42140__3 = (function (ret,k,v){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$2 ? pred.cljs$core$IFn$_invoke$arity$2(k,v) : pred.call(null,k,v)))){\nreturn (f1.cljs$core$IFn$_invoke$arity$3 ? f1.cljs$core$IFn$_invoke$arity$3(ret,k,v) : f1.call(null,ret,k,v));\n} else {\nreturn ret;\n}\n});\nG__42140 = function(ret,k,v){\nswitch(arguments.length){\ncase 0:\nreturn G__42140__0.call(this);\ncase 2:\nreturn G__42140__2.call(this,ret,k);\ncase 3:\nreturn G__42140__3.call(this,ret,k,v);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__42140.cljs$core$IFn$_invoke$arity$0 = G__42140__0;\nG__42140.cljs$core$IFn$_invoke$arity$2 = G__42140__2;\nG__42140.cljs$core$IFn$_invoke$arity$3 = G__42140__3;\nreturn G__42140;\n})()\n}));\n});\n\nclojure.core.reducers.filter.cljs$lang$maxFixedArity = 2;\n\n/**\n * Takes any nested combination of sequential things (lists, vectors,\n *   etc.) and returns their contents as a single, flat foldable\n *   collection.\n */\nclojure.core.reducers.flatten = (function clojure$core$reducers$flatten(var_args){\nvar G__41993 = arguments.length;\nswitch (G__41993) {\ncase 0:\nreturn clojure.core.reducers.flatten.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn clojure.core.reducers.flatten.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nclojure.core.reducers.flatten.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn (function (x__4245__auto__){\nreturn clojure.core.reducers.flatten.cljs$core$IFn$_invoke$arity$1(x__4245__auto__);\n});\n});\n\nclojure.core.reducers.flatten.cljs$core$IFn$_invoke$arity$1 = (function (coll){\nreturn clojure.core.reducers.folder(coll,(function (f1){\nreturn (function() {\nvar G__42142 = null;\nvar G__42142__0 = (function (){\nreturn (f1.cljs$core$IFn$_invoke$arity$0 ? f1.cljs$core$IFn$_invoke$arity$0() : f1.call(null));\n});\nvar G__42142__2 = (function (ret,v){\nif(cljs.core.sequential_QMARK_(v)){\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3(clojure.core.reducers.flatten.cljs$core$IFn$_invoke$arity$1(v),f1,ret);\n} else {\nreturn (f1.cljs$core$IFn$_invoke$arity$2 ? f1.cljs$core$IFn$_invoke$arity$2(ret,v) : f1.call(null,ret,v));\n}\n});\nG__42142 = function(ret,v){\nswitch(arguments.length){\ncase 0:\nreturn G__42142__0.call(this);\ncase 2:\nreturn G__42142__2.call(this,ret,v);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__42142.cljs$core$IFn$_invoke$arity$0 = G__42142__0;\nG__42142.cljs$core$IFn$_invoke$arity$2 = G__42142__2;\nreturn G__42142;\n})()\n}));\n});\n\nclojure.core.reducers.flatten.cljs$lang$maxFixedArity = 1;\n\n/**\n * Removes values in the reduction of coll for which (pred val)\n *   returns logical true. Foldable.\n */\nclojure.core.reducers.remove = (function clojure$core$reducers$remove(var_args){\nvar G__41995 = arguments.length;\nswitch (G__41995) {\ncase 1:\nreturn clojure.core.reducers.remove.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.core.reducers.remove.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nclojure.core.reducers.remove.cljs$core$IFn$_invoke$arity$1 = (function (pred){\nreturn (function (x__4245__auto__){\nreturn clojure.core.reducers.remove.cljs$core$IFn$_invoke$arity$2(pred,x__4245__auto__);\n});\n});\n\nclojure.core.reducers.remove.cljs$core$IFn$_invoke$arity$2 = (function (pred,coll){\nreturn clojure.core.reducers.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.complement(pred),coll);\n});\n\nclojure.core.reducers.remove.cljs$lang$maxFixedArity = 2;\n\n/**\n * Ends the reduction of coll when (pred val) returns logical false.\n */\nclojure.core.reducers.take_while = (function clojure$core$reducers$take_while(var_args){\nvar G__42004 = arguments.length;\nswitch (G__42004) {\ncase 1:\nreturn clojure.core.reducers.take_while.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.core.reducers.take_while.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nclojure.core.reducers.take_while.cljs$core$IFn$_invoke$arity$1 = (function (pred){\nreturn (function (x__4245__auto__){\nreturn clojure.core.reducers.take_while.cljs$core$IFn$_invoke$arity$2(pred,x__4245__auto__);\n});\n});\n\nclojure.core.reducers.take_while.cljs$core$IFn$_invoke$arity$2 = (function (pred,coll){\nreturn clojure.core.reducers.reducer(coll,(function (f1){\nreturn (function() {\nvar G__42148 = null;\nvar G__42148__0 = (function (){\nreturn (f1.cljs$core$IFn$_invoke$arity$0 ? f1.cljs$core$IFn$_invoke$arity$0() : f1.call(null));\n});\nvar G__42148__2 = (function (ret,v){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(v) : pred.call(null,v)))){\nreturn (f1.cljs$core$IFn$_invoke$arity$2 ? f1.cljs$core$IFn$_invoke$arity$2(ret,v) : f1.call(null,ret,v));\n} else {\nreturn cljs.core.reduced(ret);\n}\n});\nvar G__42148__3 = (function (ret,k,v){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$2 ? pred.cljs$core$IFn$_invoke$arity$2(k,v) : pred.call(null,k,v)))){\nreturn (f1.cljs$core$IFn$_invoke$arity$3 ? f1.cljs$core$IFn$_invoke$arity$3(ret,k,v) : f1.call(null,ret,k,v));\n} else {\nreturn cljs.core.reduced(ret);\n}\n});\nG__42148 = function(ret,k,v){\nswitch(arguments.length){\ncase 0:\nreturn G__42148__0.call(this);\ncase 2:\nreturn G__42148__2.call(this,ret,k);\ncase 3:\nreturn G__42148__3.call(this,ret,k,v);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__42148.cljs$core$IFn$_invoke$arity$0 = G__42148__0;\nG__42148.cljs$core$IFn$_invoke$arity$2 = G__42148__2;\nG__42148.cljs$core$IFn$_invoke$arity$3 = G__42148__3;\nreturn G__42148;\n})()\n}));\n});\n\nclojure.core.reducers.take_while.cljs$lang$maxFixedArity = 2;\n\n/**\n * Ends the reduction of coll after consuming n values.\n */\nclojure.core.reducers.take = (function clojure$core$reducers$take(var_args){\nvar G__42015 = arguments.length;\nswitch (G__42015) {\ncase 1:\nreturn clojure.core.reducers.take.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.core.reducers.take.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nclojure.core.reducers.take.cljs$core$IFn$_invoke$arity$1 = (function (n){\nreturn (function (x__4245__auto__){\nreturn clojure.core.reducers.take.cljs$core$IFn$_invoke$arity$2(n,x__4245__auto__);\n});\n});\n\nclojure.core.reducers.take.cljs$core$IFn$_invoke$arity$2 = (function (n,coll){\nreturn clojure.core.reducers.reducer(coll,(function (f1){\nvar cnt = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(n);\nreturn ((function (cnt){\nreturn (function() {\nvar G__42151 = null;\nvar G__42151__0 = (function (){\nreturn (f1.cljs$core$IFn$_invoke$arity$0 ? f1.cljs$core$IFn$_invoke$arity$0() : f1.call(null));\n});\nvar G__42151__2 = (function (ret,v){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(cnt,cljs.core.dec);\n\nif((cljs.core.deref(cnt) < (0))){\nreturn cljs.core.reduced(ret);\n} else {\nreturn (f1.cljs$core$IFn$_invoke$arity$2 ? f1.cljs$core$IFn$_invoke$arity$2(ret,v) : f1.call(null,ret,v));\n}\n});\nvar G__42151__3 = (function (ret,k,v){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(cnt,cljs.core.dec);\n\nif((cljs.core.deref(cnt) < (0))){\nreturn cljs.core.reduced(ret);\n} else {\nreturn (f1.cljs$core$IFn$_invoke$arity$3 ? f1.cljs$core$IFn$_invoke$arity$3(ret,k,v) : f1.call(null,ret,k,v));\n}\n});\nG__42151 = function(ret,k,v){\nswitch(arguments.length){\ncase 0:\nreturn G__42151__0.call(this);\ncase 2:\nreturn G__42151__2.call(this,ret,k);\ncase 3:\nreturn G__42151__3.call(this,ret,k,v);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__42151.cljs$core$IFn$_invoke$arity$0 = G__42151__0;\nG__42151.cljs$core$IFn$_invoke$arity$2 = G__42151__2;\nG__42151.cljs$core$IFn$_invoke$arity$3 = G__42151__3;\nreturn G__42151;\n})()\n;})(cnt))\n}));\n});\n\nclojure.core.reducers.take.cljs$lang$maxFixedArity = 2;\n\n/**\n * Elides the first n values from the reduction of coll.\n */\nclojure.core.reducers.drop = (function clojure$core$reducers$drop(var_args){\nvar G__42017 = arguments.length;\nswitch (G__42017) {\ncase 1:\nreturn clojure.core.reducers.drop.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.core.reducers.drop.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nclojure.core.reducers.drop.cljs$core$IFn$_invoke$arity$1 = (function (n){\nreturn (function (x__4245__auto__){\nreturn clojure.core.reducers.drop.cljs$core$IFn$_invoke$arity$2(n,x__4245__auto__);\n});\n});\n\nclojure.core.reducers.drop.cljs$core$IFn$_invoke$arity$2 = (function (n,coll){\nreturn clojure.core.reducers.reducer(coll,(function (f1){\nvar cnt = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(n);\nreturn ((function (cnt){\nreturn (function() {\nvar G__42154 = null;\nvar G__42154__0 = (function (){\nreturn (f1.cljs$core$IFn$_invoke$arity$0 ? f1.cljs$core$IFn$_invoke$arity$0() : f1.call(null));\n});\nvar G__42154__2 = (function (ret,v){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(cnt,cljs.core.dec);\n\nif((cljs.core.deref(cnt) < (0))){\nreturn (f1.cljs$core$IFn$_invoke$arity$2 ? f1.cljs$core$IFn$_invoke$arity$2(ret,v) : f1.call(null,ret,v));\n} else {\nreturn ret;\n}\n});\nvar G__42154__3 = (function (ret,k,v){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(cnt,cljs.core.dec);\n\nif((cljs.core.deref(cnt) < (0))){\nreturn (f1.cljs$core$IFn$_invoke$arity$3 ? f1.cljs$core$IFn$_invoke$arity$3(ret,k,v) : f1.call(null,ret,k,v));\n} else {\nreturn ret;\n}\n});\nG__42154 = function(ret,k,v){\nswitch(arguments.length){\ncase 0:\nreturn G__42154__0.call(this);\ncase 2:\nreturn G__42154__2.call(this,ret,k);\ncase 3:\nreturn G__42154__3.call(this,ret,k,v);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__42154.cljs$core$IFn$_invoke$arity$0 = G__42154__0;\nG__42154.cljs$core$IFn$_invoke$arity$2 = G__42154__2;\nG__42154.cljs$core$IFn$_invoke$arity$3 = G__42154__3;\nreturn G__42154;\n})()\n;})(cnt))\n}));\n});\n\nclojure.core.reducers.drop.cljs$lang$maxFixedArity = 2;\n\n\n/**\n* @constructor\n * @implements {clojure.core.reducers.CollFold}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IReduce}\n*/\nclojure.core.reducers.Cat = (function (cnt,left,right){\nthis.cnt = cnt;\nthis.left = left;\nthis.right = right;\nthis.cljs$lang$protocol_mask$partition0$ = 8912898;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\nclojure.core.reducers.Cat.prototype.cljs$core$ICounted$_count$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.cnt;\n});\n\nclojure.core.reducers.Cat.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.seq(self__.left),cljs.core.seq(self__.right));\n});\n\nclojure.core.reducers.Cat.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (this$,f1){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1.cljs$core$IReduce$_reduce$arity$3(null,f1,(f1.cljs$core$IFn$_invoke$arity$0 ? f1.cljs$core$IFn$_invoke$arity$0() : f1.call(null)));\n});\n\nclojure.core.reducers.Cat.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (_,f1,init){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3(self__.right,f1,cljs.core._reduce.cljs$core$IFn$_invoke$arity$3(self__.left,f1,init));\n});\n\nclojure.core.reducers.Cat.prototype.clojure$core$reducers$CollFold$ = cljs.core.PROTOCOL_SENTINEL;\n\nclojure.core.reducers.Cat.prototype.clojure$core$reducers$CollFold$coll_fold$arity$4 = (function (this$,n,combinef,reducef){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1.cljs$core$IReduce$_reduce$arity$2(null,reducef);\n});\n\nclojure.core.reducers.Cat.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.Symbol(null,\"left\",\"left\",1241415590,null),new cljs.core.Symbol(null,\"right\",\"right\",1187949694,null)], null);\n});\n\nclojure.core.reducers.Cat.cljs$lang$type = true;\n\nclojure.core.reducers.Cat.cljs$lang$ctorStr = \"clojure.core.reducers/Cat\";\n\nclojure.core.reducers.Cat.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"clojure.core.reducers/Cat\");\n});\n\n/**\n * Positional factory function for clojure.core.reducers/Cat.\n */\nclojure.core.reducers.__GT_Cat = (function clojure$core$reducers$__GT_Cat(cnt,left,right){\nreturn (new clojure.core.reducers.Cat(cnt,left,right));\n});\n\n/**\n * A high-performance combining fn that yields the catenation of the\n *   reduced values. The result is reducible, foldable, seqable and\n *   counted, providing the identity collections are reducible, seqable\n *   and counted. The single argument version will build a combining fn\n *   with the supplied identity constructor. Tests for identity\n *   with (zero? (count x)). See also foldcat.\n */\nclojure.core.reducers.cat = (function clojure$core$reducers$cat(var_args){\nvar G__42050 = arguments.length;\nswitch (G__42050) {\ncase 0:\nreturn clojure.core.reducers.cat.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn clojure.core.reducers.cat.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.core.reducers.cat.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nclojure.core.reducers.cat.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn [];\n});\n\nclojure.core.reducers.cat.cljs$core$IFn$_invoke$arity$1 = (function (ctor){\nreturn (function() {\nvar G__42161 = null;\nvar G__42161__0 = (function (){\nreturn (ctor.cljs$core$IFn$_invoke$arity$0 ? ctor.cljs$core$IFn$_invoke$arity$0() : ctor.call(null));\n});\nvar G__42161__2 = (function (left,right){\nreturn clojure.core.reducers.cat.cljs$core$IFn$_invoke$arity$2(left,right);\n});\nG__42161 = function(left,right){\nswitch(arguments.length){\ncase 0:\nreturn G__42161__0.call(this);\ncase 2:\nreturn G__42161__2.call(this,left,right);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__42161.cljs$core$IFn$_invoke$arity$0 = G__42161__0;\nG__42161.cljs$core$IFn$_invoke$arity$2 = G__42161__2;\nreturn G__42161;\n})()\n});\n\nclojure.core.reducers.cat.cljs$core$IFn$_invoke$arity$2 = (function (left,right){\nif((cljs.core.count(left) === (0))){\nreturn right;\n} else {\nif((cljs.core.count(right) === (0))){\nreturn left;\n} else {\nreturn (new clojure.core.reducers.Cat((cljs.core.count(left) + cljs.core.count(right)),left,right));\n\n}\n}\n});\n\nclojure.core.reducers.cat.cljs$lang$maxFixedArity = 2;\n\n/**\n * .adds x to acc and returns acc\n */\nclojure.core.reducers.append_BANG_ = (function clojure$core$reducers$append_BANG_(acc,x){\nvar G__42057 = acc;\nG__42057.push(x);\n\nreturn G__42057;\n});\n/**\n * Equivalent to (fold cat append! coll)\n */\nclojure.core.reducers.foldcat = (function clojure$core$reducers$foldcat(coll){\nreturn clojure.core.reducers.fold.cljs$core$IFn$_invoke$arity$3(clojure.core.reducers.cat,clojure.core.reducers.append_BANG_,coll);\n});\n/**\n * Builds a combining fn out of the supplied operator and identity\n *   constructor. op must be associative and ctor called with no args\n *   must return an identity value for it.\n */\nclojure.core.reducers.monoid = (function clojure$core$reducers$monoid(op,ctor){\nreturn (function() {\nvar clojure$core$reducers$monoid_$_m = null;\nvar clojure$core$reducers$monoid_$_m__0 = (function (){\nreturn (ctor.cljs$core$IFn$_invoke$arity$0 ? ctor.cljs$core$IFn$_invoke$arity$0() : ctor.call(null));\n});\nvar clojure$core$reducers$monoid_$_m__2 = (function (a,b){\nreturn (op.cljs$core$IFn$_invoke$arity$2 ? op.cljs$core$IFn$_invoke$arity$2(a,b) : op.call(null,a,b));\n});\nclojure$core$reducers$monoid_$_m = function(a,b){\nswitch(arguments.length){\ncase 0:\nreturn clojure$core$reducers$monoid_$_m__0.call(this);\ncase 2:\nreturn clojure$core$reducers$monoid_$_m__2.call(this,a,b);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nclojure$core$reducers$monoid_$_m.cljs$core$IFn$_invoke$arity$0 = clojure$core$reducers$monoid_$_m__0;\nclojure$core$reducers$monoid_$_m.cljs$core$IFn$_invoke$arity$2 = clojure$core$reducers$monoid_$_m__2;\nreturn clojure$core$reducers$monoid_$_m;\n})()\n});\nclojure.core.reducers.foldvec = (function clojure$core$reducers$foldvec(v,n,combinef,reducef){\nif(cljs.core.empty_QMARK_(v)){\nreturn (combinef.cljs$core$IFn$_invoke$arity$0 ? combinef.cljs$core$IFn$_invoke$arity$0() : combinef.call(null));\n} else {\nif((cljs.core.count(v) <= n)){\nreturn clojure.core.reducers.reduce.cljs$core$IFn$_invoke$arity$3(reducef,(combinef.cljs$core$IFn$_invoke$arity$0 ? combinef.cljs$core$IFn$_invoke$arity$0() : combinef.call(null)),v);\n} else {\nvar split = cljs.core.quot(cljs.core.count(v),(2));\nvar v1 = cljs.core.subvec.cljs$core$IFn$_invoke$arity$3(v,(0),split);\nvar v2 = cljs.core.subvec.cljs$core$IFn$_invoke$arity$3(v,split,cljs.core.count(v));\nvar fc = ((function (split,v1,v2){\nreturn (function (child){\nreturn ((function (split,v1,v2){\nreturn (function (){\nreturn (clojure.core.reducers.foldvec.cljs$core$IFn$_invoke$arity$4 ? clojure.core.reducers.foldvec.cljs$core$IFn$_invoke$arity$4(child,n,combinef,reducef) : clojure.core.reducers.foldvec.call(null,child,n,combinef,reducef));\n});\n;})(split,v1,v2))\n});})(split,v1,v2))\n;\nreturn clojure.core.reducers.fjinvoke(((function (split,v1,v2,fc){\nreturn (function (){\nvar f1 = fc(v1);\nvar t2 = clojure.core.reducers.fjtask(fc(v2));\nclojure.core.reducers.fjfork(t2);\n\nvar G__42060 = (f1.cljs$core$IFn$_invoke$arity$0 ? f1.cljs$core$IFn$_invoke$arity$0() : f1.call(null));\nvar G__42061 = clojure.core.reducers.fjjoin(t2);\nreturn (combinef.cljs$core$IFn$_invoke$arity$2 ? combinef.cljs$core$IFn$_invoke$arity$2(G__42060,G__42061) : combinef.call(null,G__42060,G__42061));\n});})(split,v1,v2,fc))\n);\n\n}\n}\n});\ngoog.object.set(clojure.core.reducers.CollFold,\"null\",true);\n\nvar G__42068_42162 = clojure.core.reducers.coll_fold;\nvar G__42069_42163 = \"null\";\nvar G__42070_42164 = ((function (G__42068_42162,G__42069_42163){\nreturn (function (coll,n,combinef,reducef){\nreturn (combinef.cljs$core$IFn$_invoke$arity$0 ? combinef.cljs$core$IFn$_invoke$arity$0() : combinef.call(null));\n});})(G__42068_42162,G__42069_42163))\n;\ngoog.object.set(G__42068_42162,G__42069_42163,G__42070_42164);\n\ngoog.object.set(clojure.core.reducers.CollFold,\"object\",true);\n\nvar G__42071_42165 = clojure.core.reducers.coll_fold;\nvar G__42072_42166 = \"object\";\nvar G__42073_42167 = ((function (G__42071_42165,G__42072_42166){\nreturn (function (coll,n,combinef,reducef){\nreturn clojure.core.reducers.reduce.cljs$core$IFn$_invoke$arity$3(reducef,(combinef.cljs$core$IFn$_invoke$arity$0 ? combinef.cljs$core$IFn$_invoke$arity$0() : combinef.call(null)),coll);\n});})(G__42071_42165,G__42072_42166))\n;\ngoog.object.set(G__42071_42165,G__42072_42166,G__42073_42167);\n\ncljs.core.PersistentVector.prototype.clojure$core$reducers$CollFold$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentVector.prototype.clojure$core$reducers$CollFold$coll_fold$arity$4 = (function (v,n,combinef,reducef){\nvar v__$1 = this;\nreturn clojure.core.reducers.foldvec(v__$1,n,combinef,reducef);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/core/reducers.cljs","~:line",15,"~:column",3,"~:end-line",15,"~:end-column",24,"~:doc","A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info.","~:author","Rich Hickey"],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",["~$reduce","~$take","~$map","~$mapcat","~$cat","~$take-while","~$remove","~$drop","~$flatten","~$filter"]],"~:name","~$clojure.core.reducers","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$cljs.core","^[","~$core","^[","~$goog","^11"],"~:seen",["^J",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^[","^[","^10","^["],"~:form",["~#list",["~$ns","^V",["^17",["~:refer-clojure","~:exclude",["^K","^M","^N","^T","^Q","^L","^P","^R","^S","^O"]]],["^17",["^13",["^[","~:as","^10"]]]]],"~:flags",["^ ","^13",["^J",[]]],"~:js-deps",["^ "],"~:deps",["^11","^["]],"^X","^V","~:resource-id",["~:shadow.build.classpath/resource","clojure/core/reducers.cljs"],"~:compiled-at",1569963239503,"~:resource-name","clojure/core/reducers.cljs","~:warnings",[],"~:source",";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc\n      \"A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info.\"\n      :author \"Rich Hickey\"}\n  clojure.core.reducers\n  (:refer-clojure :exclude [reduce map mapcat filter remove take take-while drop flatten cat])\n  (:require [cljs.core :as core]))\n\n;;;;;;;;;;;;;; some fj stuff ;;;;;;;;;;\n(defn- fjtask [f]\n  f)\n\n(defn- fjinvoke [f]\n  (f))\n\n(defn- fjfork [task]\n  task)\n\n(defn- fjjoin [task]\n  (task))\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn reduce\n  \"Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv\"\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (map? coll)\n       (-kv-reduce coll f init)\n       (cond\n         (nil? coll) init\n         (array? coll) (#'array-reduce coll f init)\n         :else (-reduce coll f init)))))\n\n(defprotocol CollFold\n  (coll-fold [coll n combinef reducef]))\n\n(defn fold\n  \"Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\n\n  Note: Performing operations in parallel is currently not implemented.\"\n  ([reducef coll] (fold reducef reducef coll))\n  ([combinef reducef coll] (fold 512 combinef reducef coll))\n  ([n combinef reducef coll]\n     (coll-fold coll n combinef reducef)))\n\n(defn reducer\n  \"Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.\"\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [this f1]\n         (-reduce this f1 (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init)))))\n\n(defn folder\n  \"Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.\"\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [_ f1]\n         (-reduce coll (xf f1) (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init))\n\n       CollFold\n       (coll-fold [_ n combinef reducef]\n         (coll-fold coll n combinef (xf reducef))))))\n\n(defcurried map\n  \"Applies f to every value in the reduction of coll. Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))\n\n(defcurried mapcat\n  \"Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (reduce f1 ret (f k v)))))))\n\n(defcurried filter\n  \"Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))\n\n(defcurried flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.\"\n  {}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))\n\n(defcurried remove\n  \"Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (filter (complement pred) coll))\n\n(defcurried take-while\n  \"Ends the reduction of coll when (pred val) returns logical false.\"\n  {}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))\n\n(defcurried take\n  \"Ends the reduction of coll after consuming n values.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))\n\n(defcurried drop\n  \"Elides the first n values from the reduction of coll.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))\n\n;;do not construct this directly, use cat\n(deftype Cat [cnt left right]\n  cljs.core/ICounted\n  (-count [_] cnt)\n\n  cljs.core/ISeqable\n  (-seq [_] (concat (seq left) (seq right)))\n\n  cljs.core/IReduce\n  (-reduce [this f1] (-reduce this f1 (f1)))\n  (-reduce\n    [_  f1 init]\n    (-reduce\n     right f1\n     (-reduce left f1 init)))\n\n  CollFold\n  (coll-fold\n    [this n combinef reducef]\n    (-reduce this reducef)))\n\n(defn cat\n  \"A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.\"\n  ([] (array))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n       (zero? (count left)) right\n       (zero? (count right)) left\n       :else\n       (Cat. (+ (count left) (count right)) left right))))\n\n(defn append!\n  \".adds x to acc and returns acc\"\n  [acc x]\n  (doto acc (.push x)))\n\n(defn foldcat\n  \"Equivalent to (fold cat append! coll)\"\n  [coll]\n  (fold cat append! coll))\n\n(defn monoid\n  \"Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it.\"\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(comment\n(require '[clojure.core.reduce :as r])\n(def v (take 1000000 (range)))\n(reduce + 0 (r/map inc [1 2 3 4]))\n(into [] (r/take 12 (range 100)))\n(into [] (r/drop 12 (range 100)))\n(reduce + 0 (r/filter even? [1 2 3 4]))\n(into [] (r/filter even? [1 2 3 4]))\n(reduce + (filter even? [1 2 3 4]))\n(dotimes [_ 10] (time (reduce + 0 (r/map inc v))))\n(dotimes [_ 10] (time (reduce + 0 (map inc v))))\n(dotimes [_ 100] (time (reduce + 0 v)))\n(dotimes [_ 100] (time (reduce + 0 v)))\n(dotimes [_ 20] (time (reduce + 0 (r/map inc (r/filter even? v)))))\n(dotimes [_ 20] (time (reduce + 0 (map inc (filter even? v)))))\n(reduce + 0 (r/take-while even? [2 4 3]))\n(into [] (r/filter even? (r/flatten (r/remove #{4} [[1 2 3] 4 [5 [6 7 8]] [9] 10]))))\n(into [] (r/flatten nil))\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; fold impls ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn- foldvec\n  [v n combinef reducef]\n  (cond\n   (empty? v) (combinef)\n   (<= (count v) n) (reduce reducef (combinef) v)\n   :else\n   (let [split (quot (count v) 2)\n         v1 (subvec v 0 split)\n         v2 (subvec v split (count v))\n         fc (fn [child] #(foldvec child n combinef reducef))]\n     (fjinvoke\n      #(let [f1 (fc v1)\n             t2 (fjtask (fc v2))]\n         (fjfork t2)\n         (combinef (f1) (fjjoin t2)))))))\n\n(extend-protocol CollFold\n nil\n (coll-fold\n  [coll n combinef reducef]\n  (combinef))\n\n object\n (coll-fold\n  [coll n combinef reducef]\n  ;;can't fold, single reduce\n  (reduce reducef (combinef) coll))\n\n cljs.core/PersistentVector\n (coll-fold\n  [v n combinef reducef]\n  (foldvec v n combinef reducef))\n\n #_\n cljs.core/PersistentHashMap\n #_\n (coll-fold\n  [m n combinef reducef]\n  (.fold m n combinef reducef fjinvoke fjtask fjfork fjjoin)))\n\n","~:reader-features",["^J",["~:cljs"]],"~:cljc",false,"~:source-map-compact",["^ ","mappings","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","names",["clojure.core.reducers/fjtask","f","clojure.core.reducers/fjinvoke","clojure.core.reducers/fjfork","task","clojure.core.reducers/fjjoin","var_args","G__41862","clojure.core.reducers/reduce","js/Error","coll","clojure.core.reducers.reduce.cljs$core$IFn$_invoke$arity$3","init","cljs.core/map?","cljs.core/-kv-reduce","cljs.core/array?","fexpr__41884","cljs.core/array-reduce","cljs.core._reduce.cljs$core$IFn$_invoke$arity$3","x__4433__auto__","m__4434__auto__","clojure.core.reducers/coll-fold","goog/typeOf","m__4431__auto__","cljs.core/missing-protocol","clojure.core.reducers/CollFold","n","combinef","reducef","G__41907","clojure.core.reducers/fold","clojure.core.reducers.fold.cljs$core$IFn$_invoke$arity$3","clojure.core.reducers.fold.cljs$core$IFn$_invoke$arity$4","clojure.core.reducers/reducer","xf","js/clojure","js/clojure.core","js/clojure.core.reducers","js/clojure.core.reducers.t_clojure$core$reducers41910","clojure.core.reducers/t_clojure$core$reducers41910","_41912","meta41911","this__4374__auto__","writer__4375__auto__","opt__4376__auto__","cljs.core/-write","clojure.core.reducers/->t_clojure$core$reducers41910","this","f1","_","clojure.core.reducers/folder","js/clojure.core.reducers.t_clojure$core$reducers41943","clojure.core.reducers/t_clojure$core$reducers41943","_41945","meta41944","cljs.core/PROTOCOL_SENTINEL","clojure.core.reducers/->t_clojure$core$reducers41943","G__41952","clojure.core.reducers/map","x__4245__auto__","clojure.core.reducers.map.cljs$core$IFn$_invoke$arity$2","G__41955","G__41956","ret","k","v","G__41957","G__41958","G__41965","clojure.core.reducers/mapcat","clojure.core.reducers.mapcat.cljs$core$IFn$_invoke$arity$2","G__41974","clojure.core.reducers/filter","clojure.core.reducers.filter.cljs$core$IFn$_invoke$arity$2","pred","G__41993","clojure.core.reducers/flatten","clojure.core.reducers.flatten.cljs$core$IFn$_invoke$arity$1","cljs.core/sequential?","G__41995","clojure.core.reducers/remove","clojure.core.reducers.remove.cljs$core$IFn$_invoke$arity$2","cljs.core/complement","G__42004","clojure.core.reducers/take-while","clojure.core.reducers.take_while.cljs$core$IFn$_invoke$arity$2","cljs.core/reduced","G__42015","clojure.core.reducers/take","clojure.core.reducers.take.cljs$core$IFn$_invoke$arity$2","cnt","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","cljs.core/deref","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2","cljs.core/dec","G__42017","clojure.core.reducers/drop","clojure.core.reducers.drop.cljs$core$IFn$_invoke$arity$2","clojure.core.reducers/Cat","clojure.core.reducers/->Cat","left","right","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","cljs.core/seq","G__42050","clojure.core.reducers/cat","ctor","clojure.core.reducers.cat.cljs$core$IFn$_invoke$arity$2","cljs.core/count","clojure.core.reducers/append!","acc","x","G__42057","clojure.core.reducers/foldcat","clojure.core.reducers/monoid","op","a","b","clojure.core.reducers/foldvec","cljs.core/empty?","split","cljs.core/quot","v1","cljs.core.subvec.cljs$core$IFn$_invoke$arity$3","v2","fc","child","t2","G__42060","G__42061","goog.object/set","G__42068","G__42069","G__42070","G__42071","G__42072","G__42073","cljs.core/PersistentVector"]]],"~:cache-keys",["~#cmap",[["^1@","goog/math/math.js"],[1559507890775,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^J",[]],"~:deps-syms",["^11","~$goog.array","~$goog.asserts"]]],["^1@","goog/array/array.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11","^1R"]]],["^1@","clojure/core/reducers.cljs"],[1556316222100,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11","^["]]],["^1@","goog/debug/error.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11"]]],["^1@","goog/dom/nodetype.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11"]]],["^1@","goog/object/object.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11"]]],"~:SHADOW-TIMESTAMP",[1569627608000,1556316222000],["^1@","goog/math/long.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11","^1R","~$goog.reflect"]]],["^1@","goog/string/internal.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11"]]],["^1@","goog/functions/functions.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11"]]],["^1@","goog/structs/map.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^1@","goog/asserts/asserts.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1@","goog/uri/uri.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11","^1Q","^1R","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1@","goog/base.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",[]]],["^1@","goog/structs/structs.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11","^1Q","~$goog.object"]]],["^1@","goog/string/string.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11","~$goog.string.internal"]]],["^1@","goog/reflect/reflect.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11"]]],["^1@","goog/string/stringbuffer.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11"]]],["^1@","goog/iter/iter.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11","^1Q","^1R","~$goog.functions","~$goog.math"]]],["^1@","cljs/core.cljs"],[1556316222100,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["~$goog.math.Long","~$goog.math.Integer","^1Y","^23","^1Q","~$goog.Uri","~$goog.string.StringBuffer"]]],["^1@","goog/math/integer.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11"]]],["^1@","goog/uri/utils.js"],[1559507890775,"^1M",["^ ","^1N",null,"^1O",["^J",[]],"^1P",["^11","^1Q","^1R","^1Y"]]]]],"~:clj-info",["^ ","jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/tools.reader/1.3.0/tools.reader-1.3.0.jar!/clojure/tools/reader/default_data_readers.clj",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/edn.clj",1559876774000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/externs.clj",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/core.cljc",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/string.clj",1559876774000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/pprint.clj",1559876774000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/env.cljc",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/tools.reader/1.3.0/tools.reader-1.3.0.jar!/clojure/tools/reader/impl/inspect.clj",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/tools.reader/1.3.0/tools.reader-1.3.0.jar!/clojure/tools/reader/reader_types.clj",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map/base64_vlq.clj",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map.clj",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/java/io.clj",1559876774000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/tools.reader/1.3.0/tools.reader-1.3.0.jar!/clojure/tools/reader.clj",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/js_deps.cljc",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/set.clj",1559876774000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/tools.reader/1.3.0/tools.reader-1.3.0.jar!/clojure/tools/reader/impl/errors.clj",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/compiler.cljc",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/util.cljc",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map/base64.clj",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/tagged_literals.cljc",1556316222000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/instant.clj",1559876774000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/core.clj",1559876774000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/data.json/0.2.6/data.json-0.2.6.jar!/clojure/data/json.clj",1556312825000,"jar:file:/Users/lambda_school_loaner_94/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/analyzer.cljc",1556316222000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","clojure/core/reducers.cljs","^7",15,"^8",3,"^9",15,"^:",24,"^;","A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info.","^<","Rich Hickey"],"^=",["^ ","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G"],"~:shadow/protocol-prefixes",["^J",["clojure$core$reducers$CollFold$"]],"^H",null,"^I",["^J",["^K","^L","^M","^N","^O","^P","^Q","^R","^S","^T"]],"^U","^V","^Y",null,"^Z",["^ ","^[","^[","^10","^[","^11","^11"],"^12",["^J",["^13"]],"~:shadow/js-access-global",["^J",["Error"]],"^14",null,"~:defs",["^ ","~$t_clojure$core$reducers41910",["^ ","~:num-fields",3,"~:protocols",["^J",["~$cljs.core/IMeta","~$cljs.core/IWithMeta","~$cljs.core/IReduce"]],"^U","~$clojure.core.reducers/t_clojure$core$reducers41910","^6","clojure/core/reducers.cljs","~:type",true,"~:anonymous",true,"^8",6,"^7",72,"~:record",false,"~:tag","~$function","~:skip-protocol-flag",["^J",["^2[","^30","^31"]]],"^K",["^ ","~:protocol-inline",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",33,"^8",7,"^9",33,"^:",13,"~:arglists",["^17",["~$quote",["^17",[["~$f","~$coll"],["~$f","~$init","^3<"]]]]],"^;","Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",3,"~:max-fixed-arity",3,"~:method-params",["^17",[["~$f","^3<"],["~$f","^3=","^3<"]]],"^3:",["^17",[["~$f","^3<"],["~$f","^3=","^3<"]]],"~:arglists-meta",["^17",[null,null]]]],"^U","~$clojure.core.reducers/reduce","^6","clojure/core/reducers.cljs","^:",13,"^3>",["^ ","^3?",false,"^3@",3,"^3A",3,"^3B",["^17",[["~$f","^3<"],["~$f","^3=","^3<"]]],"^3:",["^17",[["~$f","^3<"],["~$f","^3=","^3<"]]],"^3C",["^17",[null,null]]],"^3B",["^17",[["~$f","^3<"],["~$f","^3=","^3<"]]],"~:protocol-impl",null,"^3@",3,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"~:methods",[["^ ","^3@",2,"^3?",false,"^36","~$any"],["^ ","^3@",3,"^3?",false,"^36",["^J",[null,"^3G"]]]],"^7",33,"^9",33,"^3A",3,"~:fn-var",true,"^3:",["^17",[["~$f","^3<"],["~$f","^3=","^3<"]]],"^;","Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv"],"^L",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",164,"^8",13,"^9",164,"^:",17,"^3:",["^17",["^3;",["^17",[["~$n"],["~$n","^3<"]]]]],"^;","Ends the reduction of coll after consuming n values.","^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["~$n"],["~$n","^3<"]]],"^3:",["^17",[["~$n"],["~$n","^3<"]]],"^3C",["^17",[null,null]]]],"^U","~$clojure.core.reducers/take","^6","clojure/core/reducers.cljs","^:",17,"^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["~$n"],["~$n","^3<"]]],"^3:",["^17",[["~$n"],["~$n","^3<"]]],"^3C",["^17",[null,null]]],"^3B",["^17",[["~$n"],["~$n","^3<"]]],"^3E",null,"^3@",2,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^3F",[["^ ","^3@",1,"^3?",false,"^36","^37"],["^ ","^3@",2,"^3?",false,"^36","^32"]],"^7",164,"^9",164,"^3A",2,"^3H",true,"^3:",["^17",[["~$n"],["~$n","^3<"]]],"^;","Ends the reduction of coll after consuming n values."],"^M",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",96,"^8",13,"^9",96,"^:",16,"^3:",["^17",["^3;",["^17",[["~$f"],["~$f","^3<"]]]]],"^;","Applies f to every value in the reduction of coll. Foldable.","^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["~$f"],["~$f","^3<"]]],"^3:",["^17",[["~$f"],["~$f","^3<"]]],"^3C",["^17",[null,null]]]],"^U","~$clojure.core.reducers/map","^6","clojure/core/reducers.cljs","^:",16,"^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["~$f"],["~$f","^3<"]]],"^3:",["^17",[["~$f"],["~$f","^3<"]]],"^3C",["^17",[null,null]]],"^3B",["^17",[["~$f"],["~$f","^3<"]]],"^3E",null,"^3@",2,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^3F",[["^ ","^3@",1,"^3?",false,"^36","^37"],["^ ","^3@",2,"^3?",false,"^36","~$clojure.core.reducers/t_clojure$core$reducers41943"]],"^7",96,"^9",96,"^3A",2,"^3H",true,"^3:",["^17",[["~$f"],["~$f","^3<"]]],"^;","Applies f to every value in the reduction of coll. Foldable."],"~$foldcat",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",237,"^8",7,"^9",237,"^:",14,"^3:",["^17",["^3;",["^17",[["^3<"]]]]],"^;","Equivalent to (fold cat append! coll)"],"^U","~$clojure.core.reducers/foldcat","^6","clojure/core/reducers.cljs","^:",14,"^3B",["^17",[["^3<"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^7",237,"~:ret-tag","^3G","^9",237,"^3A",1,"^3H",true,"^3:",["^17",["^3;",["^17",[["^3<"]]]]],"^;","Equivalent to (fold cat append! coll)"],"~$reducer",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",66,"^8",7,"^9",66,"^:",14,"^3:",["^17",["^3;",["^17",[["^3<","~$xf"]]]]],"^;","Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."],"^U","~$clojure.core.reducers/reducer","^6","clojure/core/reducers.cljs","^:",14,"^3B",["^17",[["^3<","^3P"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^7",66,"^3N","^32","^9",66,"^3A",2,"^3H",true,"^3:",["^17",["^3;",["^17",[["^3<","^3P"]]]]],"^;","Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."],"^N",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",106,"^8",13,"^9",106,"^:",19,"^3:",["^17",["^3;",["^17",[["~$f"],["~$f","^3<"]]]]],"^;","Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.","^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["~$f"],["~$f","^3<"]]],"^3:",["^17",[["~$f"],["~$f","^3<"]]],"^3C",["^17",[null,null]]]],"^U","~$clojure.core.reducers/mapcat","^6","clojure/core/reducers.cljs","^:",19,"^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["~$f"],["~$f","^3<"]]],"^3:",["^17",[["~$f"],["~$f","^3<"]]],"^3C",["^17",[null,null]]],"^3B",["^17",[["~$f"],["~$f","^3<"]]],"^3E",null,"^3@",2,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^3F",[["^ ","^3@",1,"^3?",false,"^36","^37"],["^ ","^3@",2,"^3?",false,"^36","^3K"]],"^7",106,"^9",106,"^3A",2,"^3H",true,"^3:",["^17",[["~$f"],["~$f","^3<"]]],"^;","Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."],"^O",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",213,"^8",7,"^9",213,"^:",10,"^3:",["^17",["^3;",["^17",[[],["~$ctor"],["~$left","~$right"]]]]],"^;","A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.","^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[[],["^3S"],["^3T","^3U"]]],"^3:",["^17",[[],["^3S"],["^3T","^3U"]]],"^3C",["^17",[null,null,null]]]],"^U","~$clojure.core.reducers/cat","^6","clojure/core/reducers.cljs","^:",10,"^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[[],["^3S"],["^3T","^3U"]]],"^3:",["^17",[[],["^3S"],["^3T","^3U"]]],"^3C",["^17",[null,null,null]]],"^3B",["^17",[[],["^3S"],["^3T","^3U"]]],"^3E",null,"^3@",2,"^3C",["^17",[null,null,null]],"^8",1,"^3?",false,"^3F",[["^ ","^3@",0,"^3?",false,"^36","~$array"],["^ ","^3@",1,"^3?",false,"^36","^37"],["^ ","^3@",2,"^3?",false,"^36",["^J",[null,"~$clojure.core.reducers/Cat"]]]],"^7",213,"^9",213,"^3A",2,"^3H",true,"^3:",["^17",[[],["^3S"],["^3T","^3U"]]],"^;","A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat."],"^P",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",152,"^8",13,"^9",152,"^:",23,"^3:",["^17",["^3;",["^17",[["~$pred"],["^3Y","^3<"]]]]],"^;","Ends the reduction of coll when (pred val) returns logical false.","^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["^3Y"],["^3Y","^3<"]]],"^3:",["^17",[["^3Y"],["^3Y","^3<"]]],"^3C",["^17",[null,null]]]],"^U","~$clojure.core.reducers/take-while","^6","clojure/core/reducers.cljs","^:",23,"^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["^3Y"],["^3Y","^3<"]]],"^3:",["^17",[["^3Y"],["^3Y","^3<"]]],"^3C",["^17",[null,null]]],"^3B",["^17",[["^3Y"],["^3Y","^3<"]]],"^3E",null,"^3@",2,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^3F",[["^ ","^3@",1,"^3?",false,"^36","^37"],["^ ","^3@",2,"^3?",false,"^36","^32"]],"^7",152,"^9",152,"^3A",2,"^3H",true,"^3:",["^17",[["^3Y"],["^3Y","^3<"]]],"^;","Ends the reduction of coll when (pred val) returns logical false."],"^Q",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",145,"^8",13,"^9",145,"^:",19,"^3:",["^17",["^3;",["^17",[["^3Y"],["^3Y","^3<"]]]]],"^;","Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.","^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["^3Y"],["^3Y","^3<"]]],"^3:",["^17",[["^3Y"],["^3Y","^3<"]]],"^3C",["^17",[null,null]]]],"^U","~$clojure.core.reducers/remove","^6","clojure/core/reducers.cljs","^:",19,"^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["^3Y"],["^3Y","^3<"]]],"^3:",["^17",[["^3Y"],["^3Y","^3<"]]],"^3C",["^17",[null,null]]],"^3B",["^17",[["^3Y"],["^3Y","^3<"]]],"^3E",null,"^3@",2,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^3F",[["^ ","^3@",1,"^3?",false,"^36","^37"],["^ ","^3@",2,"^3?",false,"^36","^3K"]],"^7",145,"^9",145,"^3A",2,"^3H",true,"^3:",["^17",[["^3Y"],["^3Y","^3<"]]],"^;","Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."],"~$fjjoin",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",29,"^8",8,"^9",29,"^:",14,"~:private",true,"^3:",["^17",["^3;",["^17",[["~$task"]]]]]],"^41",true,"^U","~$clojure.core.reducers/fjjoin","^6","clojure/core/reducers.cljs","^:",14,"^3B",["^17",[["^42"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^7",29,"^3N","^3G","^9",29,"^3A",1,"^3H",true,"^3:",["^17",["^3;",["^17",[["^42"]]]]]],"~$fjinvoke",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",23,"^8",8,"^9",23,"^:",16,"^41",true,"^3:",["^17",["^3;",["^17",[["~$f"]]]]]],"^41",true,"^U","~$clojure.core.reducers/fjinvoke","^6","clojure/core/reducers.cljs","^:",16,"^3B",["^17",[["~$f"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^7",23,"^3N","^3G","^9",23,"^3A",1,"^3H",true,"^3:",["^17",["^3;",["^17",[["~$f"]]]]]],"~$CollFold",["^ ","^5",["^ ","^6","clojure/core/reducers.cljs","^7",46,"^8",14,"^9",46,"^:",22,"~:protocol-symbol",true,"~:jsdoc",["^17",["@interface"]],"~:protocol-info",["^ ","^3F",["^ ","~$coll-fold",[["^3<","~$n","~$combinef","~$reducef"]]]]],"^47",true,"^U","~$clojure.core.reducers/CollFold","^6","clojure/core/reducers.cljs","^:",22,"^8",1,"^7",46,"^49",["^ ","^3F",["^ ","^4:",[["^3<","~$n","^4;","^4<"]]]],"~:info",null,"^9",46,"^36","^3G","~:impls",["^J",[null,"~$object","^3K","~$cljs.core/PersistentVector","^3X"]],"^48",["^17",["@interface"]]],"~$folder",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",79,"^8",7,"^9",79,"^:",13,"^3:",["^17",["^3;",["^17",[["^3<","^3P"]]]]],"^;","Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."],"^U","~$clojure.core.reducers/folder","^6","clojure/core/reducers.cljs","^:",13,"^3B",["^17",[["^3<","^3P"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^7",79,"^3N","^3K","^9",79,"^3A",2,"^3H",true,"^3:",["^17",["^3;",["^17",[["^3<","^3P"]]]]],"^;","Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."],"~$->t_clojure$core$reducers41910",["^ ","^39",null,"^5",["^ ","^34",true,"^2Z",["^J",["^2[","^30","^31"]],"^38",["^J",["^2[","^30","^31"]],"~:factory","~:positional","^3:",["^17",["^3;",["^17",[["^3<","^3P","~$meta41911"]]]]],"^;","Positional factory function for clojure.core.reducers/t_clojure$core$reducers41910.","^6",null],"^2Z",["^J",["^2[","^30","^31"]],"^U","~$clojure.core.reducers/->t_clojure$core$reducers41910","^6","clojure/core/reducers.cljs","^3B",["^17",[["^3<","^3P","^4G"]]],"^3E",null,"^3C",["^17",[null,null]],"^34",true,"^8",6,"^3?",false,"^4E","^4F","^7",72,"^3N","^32","^3A",3,"^3H",true,"^3:",["^17",["^3;",["^17",[["^3<","^3P","^4G"]]]]],"^38",["^J",["^2[","^30","^31"]],"^;","Positional factory function for clojure.core.reducers/t_clojure$core$reducers41910."],"~$append!",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",232,"^8",7,"^9",232,"^:",14,"^3:",["^17",["^3;",["^17",[["~$acc","~$x"]]]]],"^;",".adds x to acc and returns acc"],"^U","~$clojure.core.reducers/append!","^6","clojure/core/reducers.cljs","^:",14,"^3B",["^17",[["^4J","~$x"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^7",232,"^9",232,"^3A",2,"^3H",true,"^3:",["^17",["^3;",["^17",[["^4J","~$x"]]]]],"^;",".adds x to acc and returns acc"],"~$->t_clojure$core$reducers41943",["^ ","^39",null,"^5",["^ ","^34",true,"^2Z",["^J",["^4=","^2[","^30","^31"]],"^38",["^J",["^2[","^30","^31"]],"^4E","^4F","^3:",["^17",["^3;",["^17",[["^3<","^3P","~$meta41944"]]]]],"^;","Positional factory function for clojure.core.reducers/t_clojure$core$reducers41943.","^6",null],"^2Z",["^J",["^4=","^2[","^30","^31"]],"^U","~$clojure.core.reducers/->t_clojure$core$reducers41943","^6","clojure/core/reducers.cljs","^3B",["^17",[["^3<","^3P","^4M"]]],"^3E",null,"^3C",["^17",[null,null]],"^34",true,"^8",6,"^3?",false,"^4E","^4F","^7",85,"^3N","^3K","^3A",3,"^3H",true,"^3:",["^17",["^3;",["^17",[["^3<","^3P","^4M"]]]]],"^38",["^J",["^2[","^30","^31"]],"^;","Positional factory function for clojure.core.reducers/t_clojure$core$reducers41943."],"~$->Cat",["^ ","^39",null,"^5",["^ ","^2Z",["^J",["^4=","~$cljs.core/ICounted","~$cljs.core/ISeqable","^31"]],"^6","clojure/core/reducers.cljs","^:",13,"^8",10,"^4E","^4F","^7",193,"^9",193,"^3:",["^17",["^3;",["^17",[["~$cnt","^3T","^3U"]]]]],"^38",["^J",["^4P","^4Q","^31"]],"^;","Positional factory function for clojure.core.reducers/Cat."],"^2Z",["^J",["^4=","^4P","^4Q","^31"]],"^U","~$clojure.core.reducers/->Cat","^6","clojure/core/reducers.cljs","^:",13,"^3B",["^17",[["^4R","^3T","^3U"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^4E","^4F","^7",193,"^3N","^3X","^9",193,"^3A",3,"^3H",true,"^3:",["^17",["^3;",["^17",[["^4R","^3T","^3U"]]]]],"^38",["^J",["^4P","^4Q","^31"]],"^;","Positional factory function for clojure.core.reducers/Cat."],"^R",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",178,"^8",13,"^9",178,"^:",17,"^3:",["^17",["^3;",["^17",[["~$n"],["~$n","^3<"]]]]],"^;","Elides the first n values from the reduction of coll.","^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["~$n"],["~$n","^3<"]]],"^3:",["^17",[["~$n"],["~$n","^3<"]]],"^3C",["^17",[null,null]]]],"^U","~$clojure.core.reducers/drop","^6","clojure/core/reducers.cljs","^:",17,"^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["~$n"],["~$n","^3<"]]],"^3:",["^17",[["~$n"],["~$n","^3<"]]],"^3C",["^17",[null,null]]],"^3B",["^17",[["~$n"],["~$n","^3<"]]],"^3E",null,"^3@",2,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^3F",[["^ ","^3@",1,"^3?",false,"^36","^37"],["^ ","^3@",2,"^3?",false,"^36","^32"]],"^7",178,"^9",178,"^3A",2,"^3H",true,"^3:",["^17",[["~$n"],["~$n","^3<"]]],"^;","Elides the first n values from the reduction of coll."],"~$fold",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",49,"^8",7,"^9",49,"^:",11,"^3:",["^17",["^3;",["^17",[["^4<","^3<"],["^4;","^4<","^3<"],["~$n","^4;","^4<","^3<"]]]]],"^;","Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\n\n  Note: Performing operations in parallel is currently not implemented.","^3>",["^ ","^3?",false,"^3@",4,"^3A",4,"^3B",["^17",[["^4<","^3<"],["^4;","^4<","^3<"],["~$n","^4;","^4<","^3<"]]],"^3:",["^17",[["^4<","^3<"],["^4;","^4<","^3<"],["~$n","^4;","^4<","^3<"]]],"^3C",["^17",[null,null,null]]]],"^U","~$clojure.core.reducers/fold","^6","clojure/core/reducers.cljs","^:",11,"^3>",["^ ","^3?",false,"^3@",4,"^3A",4,"^3B",["^17",[["^4<","^3<"],["^4;","^4<","^3<"],["~$n","^4;","^4<","^3<"]]],"^3:",["^17",[["^4<","^3<"],["^4;","^4<","^3<"],["~$n","^4;","^4<","^3<"]]],"^3C",["^17",[null,null,null]]],"^3B",["^17",[["^4<","^3<"],["^4;","^4<","^3<"],["~$n","^4;","^4<","^3<"]]],"^3E",null,"^3@",4,"^3C",["^17",[null,null,null]],"^8",1,"^3?",false,"^3F",[["^ ","^3@",2,"^3?",false,"^36","^3G"],["^ ","^3@",3,"^3?",false,"^36","^3G"],["^ ","^3@",4,"^3?",false,"^36","^3G"]],"^7",49,"^9",49,"^3A",4,"^3H",true,"^3:",["^17",[["^4<","^3<"],["^4;","^4<","^3<"],["~$n","^4;","^4<","^3<"]]],"^;","Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\n\n  Note: Performing operations in parallel is currently not implemented."],"~$Cat",["^ ","^2Y",3,"^2Z",["^J",["^4=","^4P","^4Q","^31"]],"^U","^3X","^6","clojure/core/reducers.cljs","^:",13,"^33",true,"^8",10,"^7",193,"^35",false,"^9",193,"^36","^37","^38",["^J",["^4P","^4Q","^31"]]],"^S",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",130,"^8",13,"^9",130,"^:",20,"^3:",["^17",["^3;",["^17",[[],["^3<"]]]]],"^;","Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.","^3>",["^ ","^3?",false,"^3@",1,"^3A",1,"^3B",["^17",[[],["^3<"]]],"^3:",["^17",[[],["^3<"]]],"^3C",["^17",[null,null]]]],"^U","~$clojure.core.reducers/flatten","^6","clojure/core/reducers.cljs","^:",20,"^3>",["^ ","^3?",false,"^3@",1,"^3A",1,"^3B",["^17",[[],["^3<"]]],"^3:",["^17",[[],["^3<"]]],"^3C",["^17",[null,null]]],"^3B",["^17",[[],["^3<"]]],"^3E",null,"^3@",1,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^3F",[["^ ","^3@",0,"^3?",false,"^36","^37"],["^ ","^3@",1,"^3?",false,"^36","^3K"]],"^7",130,"^9",130,"^3A",1,"^3H",true,"^3:",["^17",[[],["^3<"]]],"^;","Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."],"^T",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",117,"^8",13,"^9",117,"^:",19,"^3:",["^17",["^3;",["^17",[["^3Y"],["^3Y","^3<"]]]]],"^;","Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.","^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["^3Y"],["^3Y","^3<"]]],"^3:",["^17",[["^3Y"],["^3Y","^3<"]]],"^3C",["^17",[null,null]]]],"^U","~$clojure.core.reducers/filter","^6","clojure/core/reducers.cljs","^:",19,"^3>",["^ ","^3?",false,"^3@",2,"^3A",2,"^3B",["^17",[["^3Y"],["^3Y","^3<"]]],"^3:",["^17",[["^3Y"],["^3Y","^3<"]]],"^3C",["^17",[null,null]]],"^3B",["^17",[["^3Y"],["^3Y","^3<"]]],"^3E",null,"^3@",2,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^3F",[["^ ","^3@",1,"^3?",false,"^36","^37"],["^ ","^3@",2,"^3?",false,"^36","^3K"]],"^7",117,"^9",117,"^3A",2,"^3H",true,"^3:",["^17",[["^3Y"],["^3Y","^3<"]]],"^;","Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."],"~$fjtask",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",20,"^8",8,"^9",20,"^:",14,"^41",true,"^3:",["^17",["^3;",["^17",[["~$f"]]]]]],"^41",true,"^U","~$clojure.core.reducers/fjtask","^6","clojure/core/reducers.cljs","^:",14,"^3B",["^17",[["~$f"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^7",20,"^9",20,"^3A",1,"^3H",true,"^3:",["^17",["^3;",["^17",[["~$f"]]]]]],"~$monoid",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",242,"^8",7,"^9",242,"^:",13,"^3:",["^17",["^3;",["^17",[["~$op","^3S"]]]]],"^;","Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it."],"^U","~$clojure.core.reducers/monoid","^6","clojure/core/reducers.cljs","^:",13,"^3B",["^17",[["^51","^3S"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^7",242,"^3N","^37","^9",242,"^3A",2,"^3H",true,"^3:",["^17",["^3;",["^17",[["^51","^3S"]]]]],"^;","Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it."],"^4:",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",47,"^8",4,"^9",47,"^:",13,"~:protocol","^4=","^;",null,"^3:",["^17",["^3;",["^17",[["^3<","~$n","^4;","^4<"]]]]]],"^53","^4=","^U","~$clojure.core.reducers/coll-fold","^6","clojure/core/reducers.cljs","^:",13,"^3B",["^17",[["^3<","~$n","^4;","^4<"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^7",46,"^3N","^3G","^9",47,"^3A",4,"^3H",true,"^3:",["^17",["^3;",["^17",[["^3<","~$n","^4;","^4<"]]]]],"^;",null],"~$foldvec",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",273,"^8",8,"^9",273,"^:",15,"^41",true,"^3:",["^17",["^3;",["^17",[["~$v","~$n","^4;","^4<"]]]]]],"^41",true,"^U","~$clojure.core.reducers/foldvec","^6","clojure/core/reducers.cljs","^:",15,"^3B",["^17",[["~$v","~$n","^4;","^4<"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^7",273,"^3N",["^J",[null,"^3G"]],"^9",273,"^3A",4,"^3H",true,"^3:",["^17",["^3;",["^17",[["~$v","~$n","^4;","^4<"]]]]]],"~$fjfork",["^ ","^39",null,"^5",["^ ","^6","clojure/core/reducers.cljs","^7",26,"^8",8,"^9",26,"^:",14,"^41",true,"^3:",["^17",["^3;",["^17",[["^42"]]]]]],"^41",true,"^U","~$clojure.core.reducers/fjfork","^6","clojure/core/reducers.cljs","^:",14,"^3B",["^17",[["^42"]]],"^3E",null,"^3C",["^17",[null,null]],"^8",1,"^3?",false,"^7",26,"^9",26,"^3A",1,"^3H",true,"^3:",["^17",["^3;",["^17",[["^42"]]]]]],"~$t_clojure$core$reducers41943",["^ ","^2Y",3,"^2Z",["^J",["^4=","^2[","^30","^31"]],"^U","^3K","^6","clojure/core/reducers.cljs","^33",true,"^34",true,"^8",6,"^7",85,"^35",false,"^36","^37","^38",["^J",["^2[","^30","^31"]]]],"^15",["^ ","^[","^[","^10","^["],"~:cljs.analyzer/constants",["^ ","^12",["^J",["~$idx","^41","~:else","^3T","^X","^U","^[","^6","^:","^3>","^3B","^3@","^3C","~$arr","^8","^4G","~$array-reduce","^3?","^3<","^7","~$val","^3P","^4R","^9","~$cljs.core/array-reduce","^3A","^4M","^3:","^;","~:test","^3U","~$f"]],"~:order",["^5@","^41","^X","^U","^6","^:","^3>","^8","^7","^9","^3:","^;","^5A","^[","^5>","^3?","^3@","^3A","^3B","^3C","^5=","~$f","^5?","^5;","^5<","^3<","^3P","^4G","^4M","^4R","^3T","^3U"]],"^1<",["^ ","^13",["^J",[]]],"^1=",["^ "],"^1>",["^11","^["]],"^X","^V","~:ns-specs",["^ "],"~:ns-spec-vars",[],"~:compiler-options",["^1L",[["^5E","~:static-fns"],true,["^5E","~:elide-asserts"],false,["^5E","~:optimize-constants"],null,["^5E","^1C"],null,["^5E","~:external-config"],null,["^5E","~:tooling-config"],null,["^5E","~:emit-constants"],null,["^5E","~:load-tests"],null,["^5E","~:form-size-threshold"],null,["^5E","~:infer-externs"],true,["^5E","^1E"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^5E","~:fn-invoke-direct"],null,["^5E","~:source-map"],"/dev/null"]]]